"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[980],{11611:e=>{e.exports=JSON.parse('{"functions":[{"name":"Copy","desc":"Creates a copy of the given table. By default, a shallow copy is\\nperformed. For deep copies, a second boolean argument must be\\npassed to the function.\\n\\n:::caution No cyclical references\\nDeep copies are _not_ protected against cyclical references. Passing\\na table with cyclical references _and_ the `deep` parameter set to\\n`true` will result in a stack-overflow.","params":[{"name":"tbl","desc":"Table to copy","lua_type":"table"},{"name":"deep","desc":"Whether or not to perform a deep copy","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":35,"path":"src/TblUtil.lua"}},{"name":"Sync","desc":"Synchronizes the `srcTbl` based on the `templateTbl`. This will make\\nsure that `srcTbl` has all of the same keys as `templateTbl`, including\\nremoving keys in `srcTbl` that are not present in `templateTbl`. This\\nis a _deep_ operation, so any nested tables will be synchronized as\\nwell.\\n\\n```lua\\nlocal template = {kills = 0, deaths = 0, xp = 0}\\nlocal data = {kills = 10, experience = 12}\\ndata = TableUtil.Sync(data, template)\\nprint(data) --\x3e {kills = 10, deaths = 0, xp = 0}\\n```\\n\\n:::caution Data Loss Warning\\nThis is a two-way sync, so the source table will have data\\n_removed_ that isn\'t found in the template table. This can\\nbe problematic if used for player data, where there might\\nbe dynamic data added that isn\'t in the template.\\n\\nFor player data, use `TableUtil.Reconcile` instead.","params":[{"name":"srcTbl","desc":"Source table","lua_type":"table"},{"name":"templateTbl","desc":"Template table","lua_type":"table"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":79,"path":"src/TblUtil.lua"}},{"name":"Reconcile","desc":"Performs a one-way sync on the `source` table against the\\n`template` table. Any keys found in `template` that are\\nnot found in `source` will be added to `source`. This is\\nuseful for syncing player data against data template tables\\nto ensure players have all the necessary keys, while\\nmaintaining existing keys that may no longer be in the\\ntemplate.\\n\\nThis is a deep operation, so nested tables will also be\\nproperly reconciled.\\n\\n```lua\\nlocal template = {kills = 0, deaths = 0, xp = 0}\\nlocal data = {kills = 10, abc = 20}\\nlocal correctedData = TableUtil.Reconcile(data, template)\\n\\nprint(correctedData) --\x3e {kills = 10, deaths = 0, xp = 0, abc = 20}\\n```","params":[{"name":"source","desc":"","lua_type":"table"},{"name":"template","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":151,"path":"src/TblUtil.lua"}},{"name":"SwapRemove","desc":"Removes index `i` in the table by swapping the value at `i` with\\nthe last value in the array, and then trimming off the last\\nvalue from the array.\\n\\nThis allows removal of the value at `i` in `O(1)` time, but does\\nnot preserve array ordering. If a value needs to be removed from\\nan array, but ordering of the array does not matter, using\\n`SwapRemove` is always preferred over `table.remove`.\\n\\nIn the following example, we remove \\"B\\" at index 2. SwapRemove does\\nthis by moving the last value \\"E\\" over top of \\"B\\", and then trimming\\noff \\"E\\" at the end of the array:\\n```lua\\nlocal t = {\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"}\\nTableUtil.SwapRemove(t, 2) -- Remove \\"B\\"\\nprint(t) --\x3e {\\"A\\", \\"E\\", \\"C\\", \\"D\\"}\\n```\\n\\n:::note Arrays only\\nThis function works on arrays, but not dictionaries.","params":[{"name":"tbl","desc":"Array","lua_type":"table"},{"name":"i","desc":"Index","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":204,"path":"src/TblUtil.lua"}},{"name":"SwapRemoveFirstValue","desc":"Performs `table.find(tbl, v)` to find the index of the given\\nvalue, and then performs `TableUtil.SwapRemove` on that index.\\n\\n```lua\\nlocal t = {\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"}\\nTableUtil.SwapRemoveFirstValue(t, \\"C\\")\\nprint(t) --\x3e {\\"A\\", \\"B\\", \\"E\\", \\"D\\"}\\n```\\n\\n:::note Arrays only\\nThis function works on arrays, but not dictionaries.","params":[{"name":"tbl","desc":"Array","lua_type":"table"},{"name":"v","desc":"Value to find","lua_type":"any"}],"returns":[{"desc":"","lua_type":"number?"}],"function_type":"static","source":{"line":229,"path":"src/TblUtil.lua"}},{"name":"Map","desc":"Performs a map operation against the given table, which can be used to\\nmap new values based on the old values at given keys/indices.\\n\\nFor example:\\n\\n```lua\\nlocal t = {A = 10, B = 20, C = 30}\\nlocal t2 = TableUtil.Map(t, function(value)\\n\\treturn value * 2\\nend)\\nprint(t2) --\x3e {A = 20, B = 40, C = 60}\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"predicate","desc":"","lua_type":"(value: any, key: any, tbl: table) -> newValue: any"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":257,"path":"src/TblUtil.lua"}},{"name":"Filter","desc":"Performs a filter operation against the given table, which can be used to\\nfilter out unwanted values from the table.\\n\\nFor example:\\n\\n```lua\\nlocal t = {A = 10, B = 20, C = 30}\\nlocal t2 = TableUtil.Filter(t, function(value, key)\\n\\treturn value > 15\\nend)\\nprint(t2) --\x3e {B = 40, C = 60}\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"predicate","desc":"","lua_type":"(value: any, key: any, tbl: table) -> keep: boolean"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":287,"path":"src/TblUtil.lua"}},{"name":"Reduce","desc":"Performs a reduce operation against the given table, which can be used to\\nreduce the table into a single value. This could be used to sum up a table\\nor transform all the values into a compound value of any kind.\\n\\nFor example:\\n\\n```lua\\nlocal t = {10, 20, 30, 40}\\nlocal result = TableUtil.Reduce(t, function(accum, value)\\n\\treturn accum + value\\nend)\\nprint(result) --\x3e 100\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"predicate","desc":"","lua_type":"(accumulator: any, value: any, index: any, tbl: table) -> result: any"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":330,"path":"src/TblUtil.lua"}},{"name":"Assign","desc":"Copies all values of the given tables into the `target` table.\\n\\n```lua\\nlocal t = {A = 10}\\nlocal t2 = {B = 20}\\nlocal t3 = {C = 30, D = 40}\\nlocal newT = TableUtil.Assign(t, t2, t3)\\nprint(newT) --\x3e {A = 10, B = 20, C = 30, D = 40}\\n```","params":[{"name":"target","desc":"","lua_type":"table"},{"name":"...","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":373,"path":"src/TblUtil.lua"}},{"name":"Extend","desc":"Extends the target array with the extension array.\\n\\n```lua\\nlocal t = {10, 20, 30}\\nlocal t2 = {30, 40, 50}\\nlocal tNew = TableUtil.Extend(t, t2)\\nprint(tNew) --\x3e {10, 20, 30, 30, 40, 50}\\n```\\n\\n:::note Arrays only\\nThis function works on arrays, but not dictionaries.","params":[{"name":"target","desc":"","lua_type":"table"},{"name":"extension","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":402,"path":"src/TblUtil.lua"}},{"name":"Reverse","desc":"Reverses the array.\\n\\n```lua\\nlocal t = {1, 5, 10}\\nlocal tReverse = TableUtil.Reverse(t)\\nprint(tReverse) --\x3e {10, 5, 1}\\n```\\n\\n:::note Arrays only\\nThis function works on arrays, but not dictionaries.","params":[{"name":"tbl","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":427,"path":"src/TblUtil.lua"}},{"name":"Shuffle","desc":"Shuffles the table.\\n\\n```lua\\nlocal t = {1, 2, 3, 4, 5, 6, 7, 8, 9}\\nlocal shuffled = TableUtil.Shuffle(t)\\nprint(shuffled) --\x3e e.g. {9, 4, 6, 7, 3, 1, 5, 8, 2}\\n```\\n\\n:::note Arrays only\\nThis function works on arrays, but not dictionaries.","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"rngOverride","desc":"","lua_type":"Random?"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":454,"path":"src/TblUtil.lua"}},{"name":"Sample","desc":"Returns a random sample of the table.\\n\\n```lua\\nlocal t = {1, 2, 3, 4, 5, 6, 7, 8, 9}\\nlocal sample = TableUtil.Sample(t, 3)\\nprint(sample) --\x3e e.g. {6, 2, 5}\\n```\\n\\n:::note Arrays only\\nThis function works on arrays, but not dictionaries.","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"sampleSize","desc":"","lua_type":"number"},{"name":"rngOverride","desc":"","lua_type":"Random?"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":484,"path":"src/TblUtil.lua"}},{"name":"Flat","desc":"Returns a new table where all sub-arrays have been\\nbubbled up to the top. The depth at which the scan\\nis performed is dictated by the `depth` parameter,\\nwhich is set to `1` by default.\\n\\n```lua\\nlocal t = {{10, 20}, {90, 100}, {30, 15}}\\nlocal flat = TableUtil.Flat(t)\\nprint(flat) --\x3e {10, 20, 90, 100, 30, 15}\\n```\\n\\n:::note Arrays only\\nThis function works on arrays, but not dictionaries.","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"depth","desc":"","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":521,"path":"src/TblUtil.lua"}},{"name":"FlatMap","desc":"Calls `TableUtil.Map` on the given table and predicate, and then\\ncalls `TableUtil.Flat` on the result from the map operation.\\n\\n```lua\\nlocal t = {10, 20, 30}\\nlocal result = TableUtil.FlatMap(t, function(value)\\n\\treturn {value, value * 2}\\nend)\\nprint(result) --\x3e {10, 20, 20, 40, 30, 60}\\n```\\n\\n:::note Arrays only\\nThis function works on arrays, but not dictionaries.","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"predicate","desc":"","lua_type":"(key: any, value: any, tbl: table) -> newValue: any"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":558,"path":"src/TblUtil.lua"}},{"name":"Keys","desc":"Returns an array with all the keys in the table.\\n\\n```lua\\nlocal t = {A = 10, B = 20, C = 30}\\nlocal keys = TableUtil.Keys(t)\\nprint(keys) --\x3e {\\"A\\", \\"B\\", \\"C\\"}\\n```\\n\\n:::caution Ordering\\nThe ordering of the keys is never guaranteed. If order is imperative, call\\n`table.sort` on the resulting `keys` array.\\n```lua\\nlocal keys = TableUtil.Keys(t)\\ntable.sort(keys)\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":584,"path":"src/TblUtil.lua"}},{"name":"Values","desc":"Returns an array with all the values in the table.\\n\\n```lua\\nlocal t = {A = 10, B = 20, C = 30}\\nlocal values = TableUtil.Values(t)\\nprint(values) --\x3e {10, 20, 30}\\n```\\n\\n:::caution Ordering\\nThe ordering of the values is never guaranteed. If order is imperative, call\\n`table.sort` on the resulting `values` array.\\n```lua\\nlocal values = TableUtil.Values(t)\\ntable.sort(values)\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":614,"path":"src/TblUtil.lua"}},{"name":"Find","desc":"Performs a linear scan across the table and calls `callback` on\\neach item in the array. Returns the value and key of the first\\npair in which the callback returns `true`.\\n\\n```lua\\nlocal t = {\\n\\t{Name = \\"Bob\\", Age = 20};\\n\\t{Name = \\"Jill\\", Age = 30};\\n\\t{Name = \\"Ann\\", Age = 25};\\n}\\n\\n-- Find first person who has a name starting with J:\\nlocal firstPersonWithJ = TableUtil.Find(t, function(person)\\n\\treturn person.Name:sub(1, 1):lower() == \\"j\\"\\nend)\\n\\nprint(firstPersonWithJ) --\x3e {Name = \\"Jill\\", Age = 30}\\n```\\n\\n:::caution Dictionary Ordering\\nWhile `Find` can also be used with dictionaries, dictionary ordering is never\\nguaranteed, and thus the result could be different if there are more\\nthan one possible matches given the data and callback function.","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"callback","desc":"","lua_type":"(value: any, index: any, tbl: table) -> boolean"}],"returns":[{"desc":"","lua_type":"(value: any?, key: any?)"}],"function_type":"static","source":{"line":653,"path":"src/TblUtil.lua"}},{"name":"Every","desc":"Returns `true` if the `callback` also returns `true` for _every_\\nitem in the table.\\n\\n```lua\\nlocal t = {10, 20, 40, 50, 60}\\n\\nlocal allAboveZero = TableUtil.Every(t, function(value)\\n\\treturn value > 0\\nend)\\n\\nprint(\\"All above zero:\\", allAboveZero) --\x3e All above zero: true\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"callback","desc":"","lua_type":"(value: any, index: any, tbl: table) -> boolean"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":682,"path":"src/TblUtil.lua"}},{"name":"Some","desc":"Returns `true` if the `callback` also returns `true` for _at least\\none_ of the items in the table.\\n\\n```lua\\nlocal t = {10, 20, 40, 50, 60}\\n\\nlocal someBelowTwenty = TableUtil.Some(t, function(value)\\n\\treturn value < 20\\nend)\\n\\nprint(\\"Some below twenty:\\", someBelowTwenty) --\x3e Some below twenty: true\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"callback","desc":"","lua_type":"(value: any, index: any, tbl: table) -> boolean"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":711,"path":"src/TblUtil.lua"}},{"name":"Truncate","desc":"Returns a new table truncated to the length of `length`. Any length\\nequal or greater than the current length will simply return a\\nshallow copy of the table.\\n\\n```lua\\nlocal t = {10, 20, 30, 40, 50, 60, 70, 80}\\nlocal tTruncated = TableUtil.Truncate(t, 3)\\nprint(tTruncated) --\x3e {10, 20, 30}\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"},{"name":"length","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":737,"path":"src/TblUtil.lua"}},{"name":"Zip","desc":"Returns an iterator that can scan through multiple tables at the same time side-by-side, matching\\nagainst shared keys/indices.\\n\\n```lua\\nlocal t1 = {10, 20, 30, 40, 50}\\nlocal t2 = {60, 70, 80, 90, 100}\\n\\nfor key,values in TableUtil.Zip(t1, t2) do\\n\\tprint(key, values)\\nend\\n\\n--[[\\n\\tOutputs:\\n\\t1 {10, 60}\\n\\t2 {20, 70}\\n\\t3 {30, 80}\\n\\t4 {40, 90}\\n\\t5 {50, 100}\\n--]]\\n```","params":[{"name":"...","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"(iter: (t: table, k: any) -> (key: any?, values: table?), tbl: table, startIndex: any?)"}],"function_type":"static","source":{"line":770,"path":"src/TblUtil.lua"}},{"name":"Lock","desc":"Locks the table using `table.freeze`, as well as any\\nnested tables within the given table. This will lock\\nthe whole deep structure of the table, disallowing any\\nfurther modifications.\\n\\n```lua\\nlocal tbl = {xyz = {abc = 32}}\\ntbl.xyz.abc = 28 -- Works fine\\nTableUtil.Lock(tbl)\\ntbl.xyz.abc = 64 -- Will throw an error (cannot modify readonly table)\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"table"}],"function_type":"static","source":{"line":823,"path":"src/TblUtil.lua"}},{"name":"IsEmpty","desc":"Returns `true` if the given table is empty. This is\\nsimply performed by checking if `next(tbl)` is `nil`\\nand works for both arrays and dictionaries. This is\\nuseful when needing to check if a table is empty but\\nnot knowing if it is an array or dictionary.\\n\\n```lua\\nTableUtil.IsEmpty({}) -- true\\nTableUtil.IsEmpty({\\"abc\\"}) -- false\\nTableUtil.IsEmpty({abc = 32}) -- false\\n```","params":[{"name":"tbl","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":853,"path":"src/TblUtil.lua"}},{"name":"EncodeJSON","desc":"Proxy for [`HttpService:JSONEncode`](https://developer.roblox.com/en-us/api-reference/function/HttpService/JSONEncode).","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"string"}],"function_type":"static","source":{"line":865,"path":"src/TblUtil.lua"}},{"name":"DecodeJSON","desc":"Proxy for [`HttpService:JSONDecode`](https://developer.roblox.com/en-us/api-reference/function/HttpService/JSONDecode).","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"string"}],"function_type":"static","source":{"line":877,"path":"src/TblUtil.lua"}},{"name":"ShallowReconcile","desc":"Performs a one-way sync on the `source` table against the\\n`template` table. Any keys found in `template` that are\\nnot found in `source` will be added to `source`. This is\\nuseful for syncing player data against data template tables\\nto ensure players have all the necessary keys, while\\nmaintaining existing keys that may no longer be in the\\ntemplate.\\n\\n\\n```lua\\nlocal template = {kills = 0, deaths = 0, xp = 0}\\nlocal data = {kills = 10, abc = 20}\\nlocal correctedData = TableUtil.ShallowReconcile(data, template)\\n\\nprint(correctedData) --\x3e {kills = 10, deaths = 0, xp = 0, abc = 20}\\n```","params":[{"name":"src","desc":"","lua_type":"S"},{"name":"template","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"S & T"}],"function_type":"static","source":{"line":930,"path":"src/TblUtil.lua"}},{"name":"ToDict","desc":"Converts an array into a dictionary using a given function to generate a new Key and Value.","params":[{"name":"array","desc":"The array to parse","lua_type":"{T}"},{"name":"fn","desc":"A function to transform the index","lua_type":"(T, number) -> (K, V)"}],"returns":[{"desc":"The new dictionary","lua_type":"{[K]: V}"}],"function_type":"static","source":{"line":958,"path":"src/TblUtil.lua"}},{"name":"Weak","desc":"A simple wrapper for making a weak table.\\nBy default just the keys are made weak, but the second argument allows specifying the mode.","params":[{"name":"tbl","desc":"The table to make weak","lua_type":"T?"},{"name":"mode","desc":"The mode to use for the weak table","lua_type":"string?"}],"returns":[{"desc":"The weak table","lua_type":"T & tbl"}],"function_type":"static","source":{"line":974,"path":"src/TblUtil.lua"}}],"properties":[],"types":[],"name":"TableUtil","desc":"A library of table manipulation functions.\\nForked from Sleitnik\'s TableUtil","source":{"line":10,"path":"src/TblUtil.lua"}}')}}]);